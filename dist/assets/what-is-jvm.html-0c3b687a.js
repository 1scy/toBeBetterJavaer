import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as l,c as p,a,d as e,b as s,e as t}from"./app-a425eb61.js";const r={},c=a("h1",{id:"第一节-jvm-到底是什么",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#第一节-jvm-到底是什么","aria-hidden":"true"},"#"),e(" 第一节：JVM 到底是什么？")],-1),d=a("p",null,"“二哥，之前的文章里提到了 JVM，说实在的，我还不知道它到底是干嘛的，你能给我普及一下吗？”三妹咪了一口麦香可可奶茶后对我说。",-1),u=a("p",null,"“三妹，不要担心，这篇文章来带你认识一下什么是 JVM，这也是 Java 中非常重要的一块知识，每个程序员都应该了解的。”说完最后这句话，我脸上忍不住泛起了一阵羞涩的红晕。",-1),v={href:"https://javabetter.cn/overview/what-is-java.html",target:"_blank",rel:"noopener noreferrer"},h=t('<p>一开始，项目组打算使用 C++，但 C++ 无法达到跨平台的要求，比如在 Windows 系统下编译的 Hello.exe 无法直接拿到 Linux 环境下执行。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-01.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在当时，C++ 已经非常流行了，但无法跨平台，只能忍痛割爱了。</p><p>怎么办呢？</p><p>三妹不知道有没有听过直译器（解释器）这玩意？（估计你没听过）就是每跑一行代码就生成机器码，然后执行，比如说 Python 和 Ruby 用的就是直译器。在每个操作系统上装一个直译器就好了，跨平台的目的就达到了。</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-02.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但直译器有个缺点，就是没法像编译器那样对一些热点代码进行优化，从而让机器码跑得更快一些。</p><p>怎么办呢？</p><p>来个结合体呗，编译器和直译器一块上！</p><figure><img src="https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231019153456.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10),g={href:"https://javabetter.cn/jvm/bytecode.html",target:"_blank",rel:"noopener noreferrer"},m=t(`<p>不仅跨平台的目的达到了，而且性能得到了优化。</p><p>三妹是不是想问，“为什么 Java 虚拟机会叫 Java 虚拟机呢？”</p><p>虚拟机，顾名思义，就是虚拟的机器（多苍白的解释），反正就是看不见摸不着的机器，把它想象成一个会执行字节码的怪兽吧。</p><p>记得上大学那会，由于没有 Linux 环境，但又需要在上面玩一些命令，于是就在 Windows 上装 Linux 的虚拟机，这个 JVM 就类似这种东西。</p><p>说白了，就是我们编写 Java 代码，编译 Java 代码，目的不是让它在 Linux、Windows 或者 MacOS 上跑，而是在 JVM 上跑。</p><h2 id="虚拟机家族" tabindex="-1"><a class="header-anchor" href="#虚拟机家族" aria-hidden="true">#</a> 虚拟机家族</h2><p>说到这，三妹是不是想问，“都有哪些 Java 虚拟机呢？”来看下面这张思维导图：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-04.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>除了我们经常看到，经常听到的 Hotspot VM，还有很多，下面我来简单介绍一下。</p><ul><li><p>Sun Classic：世界上第一款商用 Java 虚拟机，但执行效率低下，导致 Java 程序的性能和 C/C++ 存在很大差距，因此给后来者留下了“Java 语言很慢”的刻板印象。</p></li><li><p>Exact VM：为了提升 Classic 的效率，Sun 的虚拟机团队曾在 Solaris（Sun 研发的一款类似 Unix 的操作系统）上发布过这款虚拟机，它的执行系统里包含有热点探测、即时编译等，但不是很成熟。</p></li></ul><p>Sun Classic 在 JDK 1.4 的时候被彻底抛弃，而 Exact VM 被抛弃得更早，取代它的正是 HotSpot VM——时也命也。</p><ul><li>HotSpot VM：OracleJDK（商用）和 OpenJDK（开源）的默认虚拟机，也是目前使用最广泛的 Java 虚拟机。</li></ul><p>HotSpot 的技术优势就在于热点代码探测技术（名字就从这来）和准确式内存管理技术，但其实这两个技术在 Exact VM 中都有体现，因此你看起个好的名字多重要（开玩笑了，这就是命）。</p><p>热点代码探测，指的是，通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译，解释器就可以不再逐行的将字节码翻译成机器码，而是将一整个方法的所有字节码翻译成机器码再执行。</p><p>这样的话，效率就提高了很多，对吧？</p><ul><li><p>Mobile VM：Java 在移动手机端（被 Android 和 IOS 二分天下）的发展并没有那么成功，因此 Mobile VM 的声望值比较低。</p></li><li><p>Embedded VM：嵌入式设备上的虚拟机。</p></li><li><p>BEA JRockit：曾经号称是“世界上最快的 Java 虚拟机”，后来被 Oracle 收购后就没有声音了。</p></li><li><p>IBM J9 VM：提起 IBM，基本上所有程序员都知道了，也是个巨头，所以他家的虚拟机也很强，在职责分离和模块化上做得比 HotSpot 更好。目前已经开源给 Eclipse 基金会。</p></li><li><p>BEA Liquid VM：是 BEA 公司开发的可以直接运行在自家系统上的虚拟机，可以越过操作系统直接和硬件打交道，因此可以更大程度上的发挥硬件的能力。不过核心用的还是 JRockit，所以伴随着 JRockit 的消失，Liquid VM 也退出历史舞台了。</p></li><li><p>Azul VM：是 Azul 公司在 HotSpot 基础上进行大量改进后的，可以运行在 Azul 公司专有硬件上的虚拟机。2010 年起，Azul 公司的重心从硬件转移到软件上，并发布了 Zing 虚拟机，性能方面很强大。</p></li><li><p>Apache Harmony 和 Google Android Dalvik VM 并不是 严格意义上的 Java 虚拟机，但对 Java 虚拟机的发展起到了很大的刺激作用。但它们终究没有熬过时间。</p></li><li><p>Microsoft JVM：在早期的 Java Applets 年代，微软为了在 IE 中支持 Applets 开发了自己的 Java 虚拟机。你敢相信？Microsoft JVM 只有 Windows 版本，它与 JVM 实现的“一次编译，到处运行”的理念完全沾不上边。</p></li></ul><p>关键是，1997 年 10 月，Sun 公司因为这事把微软告了，最后微软赔给了 Sun 公司 2000 万美金，并且终止了在 Java 虚拟机方面的发展。如果，我是说如果，如果微软保持着对 Java 的热情，后面还有 .Net 什么事？</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-05.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="jvm-长什么样" tabindex="-1"><a class="header-anchor" href="#jvm-长什么样" aria-hidden="true">#</a> JVM 长什么样</h2><p>解释了这么多 Java 虚拟机后，三妹是不是想问，“Java 虚拟机长什么样子呢？”</p><p>Java 虚拟机虽然是虚拟的，但它的内部是可以划分为：</p><ul><li>类加载器（Class Loader）</li><li>运行时数据区（Runtime Data Areas）</li><li>执行引擎（Excution Engine）</li></ul><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-06.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-类加载器" tabindex="-1"><a class="header-anchor" href="#_1-类加载器" aria-hidden="true">#</a> 1）类加载器</h3><p>类加载器是 Java 虚拟机的一个子系统，用于加载类文件。每当我们运行一个 Java 程序，它都会由类加载器首先加载。</p><p>一般来说，Java 程序员并不需要直接同类加载器进行交互。JVM 默认的行为就已经足够满足大多数情况的需求了。不过，如果遇到了需要和类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就不得不花大量的时间去调试<br><code>ClassNotFoundException</code> 和 <code>NoClassDefFoundError</code> 等异常。</p><p>对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在 JVM 中的唯一性。也就是说，如果两个类的加载器不同，即使两个类来源于同一个字节码文件，那这两个类就必定不相等（比如两个类的 Class 对象不 <code>equals</code>）。</p><p>来通过一段简单的代码了解下。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * <span class="token keyword">@author</span> 微信搜「沉默王二」，回复关键字 PDF
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ClassLoader</span> loader <span class="token operator">=</span> <span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>loader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span>
            loader <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每个 Java 类都维护着一个指向定义它的类加载器的引用，通过 <code>类名.class.getClassLoader()</code> 可以获取到此引用；然后通过 <code>loader.getParent()</code> 可以获取类加载器的上层类加载器。</p><p>上面这段代码的输出结果如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17
jdk.internal.loader.ClassLoaders$PlatformClassLoader@2d209079
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行输出为 Test 的类加载器，即应用类加载器，它是 <code>jdk.internal.loader.ClassLoaders$AppClassLoader</code> 类的实例；第二行输出为平台类加载器，是 <code>jdk.internal.loader.ClassLoaders$PlatformClassLoader</code> 类的实例。那启动类加载器呢？</p><p>按理说，扩展类加载器的上层类加载器是启动类加载器，但启动类加载器是虚拟机的内置类加载器，通常表示为 null。</p><h3 id="_2-运行时数据区" tabindex="-1"><a class="header-anchor" href="#_2-运行时数据区" aria-hidden="true">#</a> 2）运行时数据区</h3><p>来看下面这张图：</p><figure><img src="https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/overview/seven-07.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><p>PC 寄存器（PC Register），也叫程序计数器（Program Counter Register），是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。</p></li><li><p>JVM 栈（Java Virtual Machine Stack），与 PC 寄存器一样，JVM 栈也是线程私有的。每一个 JVM 线程都有自己的 JVM 栈，这个栈与线程同时创建，它的生命周期与线程相同。</p></li><li><p>本地方法栈（Native Method Stack），JVM 可能会使用到传统的栈来支持 Native 方法（使用 Java 语言以外的其它语言［C 语言］编写的方法）的执行，这个栈就是本地方法栈。</p></li><li><p>堆（Heap），在 JVM 中，堆是可供各条线程共享的运行时内存区域，也是供所有类实例和数据对象分配内存的区域。</p></li><li><p>方法区（Method area），在 JVM 中，被加载类型的信息都保存在方法区中。包括类型信息（Type Information）和方法列表（Method Tables）。方法区是所有线程共享的，所以访问方法区信息的方法必须是线程安全的。</p></li><li><p>运行时常量池（Runtime Constant Pool），运行时常量池是每一个类或接口的常量池在运行时的表现形式，它包括了编译器可知的数值字面量，以及运行期解析后才能获得的方法或字段的引用。简而言之，当一个方法或者变量被引用时，JVM 通过运行时常量区来查找方法或者变量在内存里的实际地址。</p></li></ul><h3 id="_3-执行引擎" tabindex="-1"><a class="header-anchor" href="#_3-执行引擎" aria-hidden="true">#</a> 3）执行引擎</h3><p>执行引擎包含了：</p><ul><li><p>解释器：读取字节码流，然后执行指令。因为它是一行一行地解释和执行指令，所以它可以很快地解释字节码，但是执行起来会比较慢（毕竟要一行执行完再执行下一行）。</p></li><li><p>即时（Just-In-Time，JIT）编译器：即时编译器用来弥补解释器的缺点，提高性能。执行引擎首先按照解释执行的方式来执行，然后在合适的时候，即时编译器把整段字节码编译成本地代码。然后，执行引擎就没有必要再去解释执行方法了，它可以直接通过本地代码去执行。执行本地代码比一条一条进行解释执行的速度快很多。编译后的代码可以执行的很快，因为本地代码是保存在缓存里的。</p></li></ul><p>“三妹，关于 Java 虚拟机，今天我们就学到这吧，后面再展开讲，怎么样？”转动了一下僵硬的脖子后，我对三妹说，“Java 虚拟机是一块很大很深的内容，如果一上来学太多的话，我怕难倒你。”</p><p>“好的，二哥，我也觉得今天的知识量够了，我要好好消化几天。我会加油的！”三妹似乎对未来充满了希望，这正是我想看到的。</p><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>总的来说，JVM是Java程序执行的环境，它隐藏了底层操作系统和硬件的复杂性，提供了一个统一、稳定和安全的运行平台。</p><hr>`,46),b={href:"https://javabetter.cn/zhishixingqiu/",target:"_blank",rel:"noopener noreferrer"},k=a("strong",null,"3700 多名",-1),f=a("img",{src:"https://cdn.tobebetterjavaer.com/paicoding/7c0ac1af155d3c1a1df268a17813ca45.png",title:"二哥的编程星球",width:"400"},null,-1),J=a("p",null,[e("这是一个"),a("strong",null,"编程学习指南 + Java 项目实战 + LeetCode 刷题的私密圈子"),e("，你可以阅读星球专栏、向二哥提问、帮你制定学习计划、和球友一起打卡成长。")],-1),_=a("figure",null,[a("img",{src:"https://cdn.tobebetterjavaer.com/stutymore/what-is-jvm-20231019155412.png",alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),M=a("p",null,[e("两个置顶帖「球友必看」和「知识图谱」里已经沉淀了非常多优质的内容，"),a("strong",null,"相信能帮助你走的更快、更稳、更远"),e("。")],-1),x={href:"https://javabetter.cn/zhishixingqiu/mianshi.html",target:"_blank",rel:"noopener noreferrer"},V={href:"https://mp.weixin.qq.com/s/AyRK5OWGYugS6s2vn2CPuA",target:"_blank",rel:"noopener noreferrer"},j={href:"https://mp.weixin.qq.com/s/7JIKnYCYtYrpAXRTjU0LLw",target:"_blank",rel:"noopener noreferrer"},C={href:"https://javabetter.cn/thread/",target:"_blank",rel:"noopener noreferrer"},w=a("p",null,[e("最后，把二哥的座右铭送给大家："),a("strong",null,"没有什么使我停留——除了目的，纵然岸旁有玫瑰、有绿荫、有宁静的港湾，我是不系之舟"),e("。")],-1);function y(L,S){const n=o("ExternalLinkIcon");return l(),p("div",null,[c,d,u,a("p",null,[e("看过《"),a("a",v,[e("Java 发展简史"),s(n)]),e("》的小伙伴应该知道，Sun 在 1991 年成立了一个由詹姆斯·高斯林（James Gosling）领导的，名为“Green”的项目组，目的是开发一种能够在各种消费性电子产品上运行的程序架构。")]),h,a("p",null,[e("编译器负责把 Java 源代码编译成字节码（"),a("a",g,[e("字节码会在后面细讲"),s(n)]),e("），Java 虚拟机（Java Virtual Machine，简称 JVM） 负责把字节码转换成机器码。转换的时候，可以做一些压缩或者优化，这样的机器码跑起来就快多了。")]),m,a("p",null,[e("一个人可以走得很快，但一群人才能走得更远。"),a("a",b,[e("二哥的编程星球"),s(n)]),e("已经有 "),k,e(" 球友加入了，如果你也需要一个良好的学习环境，扫描下方的优惠券加入我们吧。新人可免费体验 3 天，不满意可全额退款（星球官方机制😄）。")]),f,J,_,M,a("ul",null,[a("li",null,[a("a",x,[e("二哥的Java面试指南专栏发布了✌️"),s(n)])]),a("li",null,[a("a",V,[e("二哥的原创实战项目技术派上线了✌️"),s(n)])]),a("li",null,[a("a",j,[e("2000+薪资待遇还不错的公司名单✌️"),s(n)])]),a("li",null,[a("a",C,[e("二哥的并发编程小册发布了✌️"),s(n)])])]),w])}const z=i(r,[["render",y],["__file","what-is-jvm.html.vue"]]);export{z as default};
